import fetch from "node-fetch";
import InstagramMedia from "../models/instaimages.js";
import InstagramVideo from "../models/instavideos.js";
import Comment from "../models/commentModel.js";

// ================== CONFIG ==================
const ACCESS_TOKEN = process.env.INSTAGRAM_TOKEN;
const INSTAGRAM_ID = process.env.INSTAGRAM_ID;
const GRAPH_VERSION = "v19.0";

// ================== STEP 1: GET ALL MEDIA ==================
async function getAllMedia() {
  const url = `https://graph.facebook.com/${GRAPH_VERSION}/${INSTAGRAM_ID}/media?fields=id,caption&access_token=${ACCESS_TOKEN}`;
  const res = await fetch(url);
  const data = await res.json();
  return data.data || [];
}

// ================== STEP 2: GET COMMENTS ==================
async function getCommentsForMedia(mediaId) {
  const url = `https://graph.facebook.com/${GRAPH_VERSION}/${mediaId}/comments?fields=id,text,username,timestamp&access_token=${ACCESS_TOKEN}`;
  const res = await fetch(url);
  const data = await res.json();
  return data.data || [];
}

// ================== STEP 3: MATCH MEDIA ==================
async function getMatchedMediaCommentsData() {
  const photoDB = await InstagramMedia.find();
  const videoDB = await InstagramVideo.find();
  const allDBMedia = [...photoDB, ...videoDB];

  const igMediaList = await getAllMedia();
  let matchedMedia = [];

  for (const igMedia of igMediaList) {
    const dbMedia = allDBMedia.find(x => x.mediaId === igMedia.id);
    if (!dbMedia) continue;

    const comments = await getCommentsForMedia(igMedia.id);

    const isMatched = comments.some(
      c =>
        c.text?.trim().toLowerCase() ===
        dbMedia.adminComment?.trim().toLowerCase()
    );

    if (isMatched) {
      matchedMedia.push({
        mediaId: igMedia.id,
        caption: igMedia.caption,
        adminComment: dbMedia.adminComment,
        comments,
      });
    }
  }

  return matchedMedia;
}

// ================== STEP 4: AUTO-REPLY HELPER ==================
async function replyToComment(commentId, message) {
  const url = `https://graph.facebook.com/${GRAPH_VERSION}/${commentId}/replies`;

  const res = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      message,
      access_token: ACCESS_TOKEN,
    }),
  });

  const data = await res.json();

  if (data.error) {
    console.error("Reply error:", data.error);
    return false;
  }
  return true;
}

// ================== STEP 5: MAIN AUTO-REPLY LOGIC ==================
async function getNewCommentsForAutoReply() {
  const matchedMedia = await getMatchedMediaCommentsData();
  let finalResponse = [];

  for (const media of matchedMedia) {
    let dbRecord = await Comment.findOne({ mediaId: media.mediaId });

    if (!dbRecord) {
      dbRecord = new Comment({
        mediaId: media.mediaId,
        processedComments: [],
      });
    }

    const newComments = media.comments.filter(
      c => !dbRecord.processedComments.includes(c.id)
    );

    for (const c of newComments) {
      finalResponse.push({
        mediaId: media.mediaId,
        commentId: c.id,
      });

      dbRecord.processedComments.push(c.id);
    }

    await dbRecord.save();
  }

  return finalResponse;
}

// ================== API 1: JUST GET URL DATA ==================
export const urls = async (req, res) => {
  try {
    const list = await getNewCommentsForAutoReply();
    res.json(
      list.map(item => ({
        mediaId: item.mediaId,
        commentId: item.commentId,
        url: `obcd.ai/media/${item.mediaId}`,
      }))
    );
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// ================== API 2: AUTO REPLY ==================
export const autoReply = async (req, res) => {
  try {
    const commentList = await getNewCommentsForAutoReply();
    let result = [];

    for (const item of commentList) {
      // Build URL here
      const mediaUrl = `https://obcd.ai/media/${item.mediaId}`;

      const success = await replyToComment(
        item.commentId,
        `Thanks for your comment! üòä Here‚Äôs your link: ${mediaUrl}`
      );

      result.push({
        mediaId: item.mediaId,
        commentId: item.commentId,
        replied: success,
      });

      // ‚è≥ Delay to avoid Instagram rate limit
      await new Promise(r => setTimeout(r, 1500));
    }

    res.json(result);
  } catch (err) {
    console.error("AUTO REPLY ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};


export const found = async (req, res) => {
  try {
    const { mediaId } = req.params;

    // Check in images collection
    const image = await InstagramMedia.findOne({ mediaId });

    // Check in videos collection
    const video = await InstagramVideo.findOne({ mediaId });

    if (!image && !video) {
      return res.json({
        found: false,
        message: "Media not found in DB",
      });
    }

    return res.json({
      found: true,
      mediaType: image ? "image" : "video",
      media: image || video,
    });

  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};


import { found,urls,autoReply} from "../controllers/graphController.js";
router.post("/auto-reply", autoReply);






old code

// import fetch from "node-fetch";
// import InstagramMedia from "../models/instaimages.js";
// import InstagramVideo from "../models/instavideos.js";
// import comment from "../models/commentModel.js"

// const ACCESS_TOKEN = process.env.INSTAGRAM_TOKEN;
// const INSTAGRAM_ID = process.env.INSTAGRAM_ID;

// // STEP 1 ‚Äî Get all media from Instagram
// async function getAllMedia() {
//   const url = `https://graph.facebook.com/v19.0/${INSTAGRAM_ID}/media?fields=id,caption&access_token=${ACCESS_TOKEN}`;
//   const res = await fetch(url);
//   const data = await res.json();
//   return data.data;
// }

// // STEP 2 ‚Äî Get comments for a single media
// async function getCommentsForMedia(mediaId) {
//   const url = `https://graph.facebook.com/v19.0/${mediaId}/comments?fields=id,text,username,timestamp&access_token=${ACCESS_TOKEN}`;
//   const res = await fetch(url);
//   const data = await res.json();
//   return data.data || [];
// }

// // STEP 3 ‚Äî Match logic for both DBs
// export async function getMatchedMediaCommentsData() {
//   const photoDB = await InstagramMedia.find();
//   const videoDB = await InstagramVideo.find();

//   const allDBMedia = [...photoDB, ...videoDB];
//   const igMediaList = await getAllMedia();

//   let matchedMedia = [];

//   for (const igMedia of igMediaList) {
//     const dbMedia = allDBMedia.find(x => x.mediaId === igMedia.id);
//     if (!dbMedia) continue;

//     const comments = await getCommentsForMedia(igMedia.id);

//     const isMatched = comments.some(
//       c =>
//         c.text?.trim().toLowerCase() ===
//         dbMedia.adminComment?.trim().toLowerCase()
//     );

//     if (isMatched) {
//       matchedMedia.push({
//         mediaId: igMedia.id,
//         caption: igMedia.caption,
//         adminComment: dbMedia.adminComment,
//         comments,
//         image: dbMedia.image || null,
//         video: dbMedia.video || null,
//       });
//     }
//   }

//   return matchedMedia;
// }

// export const getMatchedMediaComments = async (req, res) => {
//   try {
//     const matchedMedia = await getMatchedMediaCommentsData();
//     res.json(matchedMedia);
//   } catch (error) {
//     res.status(500).json({ error: error.message });
//   }
// };


// export const getSingleMatchedMedia = async (req, res) => {
//   try {
//     const mediaId = req.params.mediaId;
//     const photo = await InstagramMedia.findOne({ mediaId });
//     const video = await InstagramVideo.findOne({ mediaId });
//     const dbMedia = photo || video;

//     if (!dbMedia) return res.status(404).json({ message: "Media not found" });

//     const comments = await getCommentsForMedia(mediaId);

//     res.json({
//       mediaId,
//       caption: dbMedia.caption,
//       adminComment: dbMedia.adminComment,
//       comments,
//       image: dbMedia.image || null,
//       video: dbMedia.video || null,
//     });
//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };



// export const urls = async (req, res) => {
//   try {
//     const matchedMedia = await getMatchedMediaCommentsData();
//     let finalResponse = [];

//     for (const media of matchedMedia) {
//       let dbRecord = await comment.findOne({ mediaId: media.mediaId });

//       if (!dbRecord) {
//         dbRecord = new comment({
//           mediaId: media.mediaId,
//           processedComments: [],
//         });
//       }

//       const newComments = media.comments.filter(
//         (c) => !dbRecord.processedComments.includes(c.id)
//       );

//       if (newComments.length === 0) continue;

//       // ‚úÖ One response per comment
//       for (const c of newComments) {
//         finalResponse.push({
//           mediaId: media.mediaId,
//           commentId: c.id,
//           url: `obcd.ai/media/${media.mediaId}`,
//         });

//         dbRecord.processedComments.push(c.id); // ONLY ONCE
//       }

//       await dbRecord.save();
//     }

//     res.json(finalResponse);

//   } catch (err) {
//     console.error("URLs ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };




// export const found = async (req, res) => {
//   try {
//     const { mediaId } = req.params;

//     // Check in images collection
//     const image = await InstagramMedia.findOne({ mediaId });

//     // Check in videos collection
//     const video = await InstagramVideo.findOne({ mediaId });

//     if (!image && !video) {
//       return res.json({
//         found: false,
//         message: "Media not found in DB",
//       });
//     }

//     return res.json({
//       found: true,
//       mediaType: image ? "image" : "video",
//       media: image || video,
//     });

//   } catch (err) {
//     res.status(500).json({ error: err.message });
//   }
// };














import dotenv from "dotenv";
dotenv.config();
const PAGE_ACCESS_TOKEN ="EAAR2Nb5jGxIBQJ3WWWx1WOHmWoLeAmwnuz6evGUL7sZBVscQs5nYbscrPffPZBl9VGpAzKe620pqAY6ceZC0XXZA2IDy4LO8vGYI9o9FlhZCSMZAzpGQMcBNzekFlZB4dluZCRzLPcEQj9VShDegnxolZBzebEaGFt9j5OP5VJov3pGTgcugTaexmTumkAdZBigQ1WzpgE8Sgp5GyYE6zrEuCOWXrXKI5dggx7LuNOlmZCjz905SyJCy9hzNIhhJQZDZD";
const VERIFY_TOKEN = "VERIFY_TOKEN";

// STEP 1: VERIFY WEBHOOK
export const verifyWebhook = (req, res) => {
   const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];

  console.log("üîπ Webhook verification attempt", { mode, token, challenge });

  if (mode === "subscribe" && token === VERIFY_TOKEN) {
    console.log("‚úÖ Webhook verified successfully");
    return res.status(200).send(challenge);
  }

  console.log("‚ùå Webhook verification failed");
  return res.sendStatus(403);

};

// ===================================
// 2Ô∏è‚É£ RECEIVE INSTAGRAM COMMENTS
// ===================================

export const receiveWebhook = async (req, res) => {
  console.log("üì© Webhook received:", JSON.stringify(req.body, null, 2));
  try {
    const entry = req.body.entry?.[0];

    // ===== Case 1: Comment webhook =====
    if (entry?.changes) {
      const change = entry.changes[0];
      const value = change.value;

      if (!value || !value.id) {
        console.log("‚ùå No comment ID found in changes");
        return res.sendStatus(200);
      }

      const commentId = value.id;
      const commentText = value.text?.toLowerCase().trim();
      const username = value.from?.username;

      console.log("üÜî Comment ID:", commentId);
      console.log("üìù Comment Text:", commentText);
      console.log("üë§ Username:", username);

      // Skip your own comments
      const YOUR_IG_USERNAME = "YOUR_INSTAGRAM_USERNAME";
      if (username === YOUR_IG_USERNAME) return res.sendStatus(200);

      // Auto-reply logic
      let replyMessage = null;
      if (commentText === "chatgpt") {
        replyMessage = "üáÆüá≥ Hello! Thanks for commenting India üòä";
      }

      if (replyMessage) {
        console.log("üí¨ Sending reply:", replyMessage);
        await new Promise(r => setTimeout(r, 3000)); // optional delay
        await sendReply(commentId, replyMessage);
      }

      return res.sendStatus(200);
    }

    // ===== Case 2: Message echo (your own DM) =====
    if (entry?.messaging) {
      entry.messaging.forEach(msg => {
        if (msg.message?.is_echo) {
          console.log("üì© DM Sent:", msg.message);
        }
      });
      return res.sendStatus(200);
    }

    // If neither, just acknowledge
    res.sendStatus(200);
  } catch (err) {
    console.error("‚ùå Webhook error:", err.response?.data || err.message);
    return res.sendStatus(200);
  }
};


// ===================================
// 4Ô∏è‚É£ SEND PUBLIC COMMENT REPLY
// ===================================
const IG_BUSINESS_ID = "102862209366036"; // Paste your ID here

async function sendReply(commentId, message) {
  try {
    const response = await fetch(
      `https://graph.facebook.com/v21.0/${IG_BUSINESS_ID}/messages`,
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${PAGE_ACCESS_TOKEN}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          recipient: { comment_id: commentId }, // Link the DM to the comment
          message: { text: message }
        })
      }
    );

    const data = await response.json(); // axios.data equivalent

    if (!response.ok) {
      console.error("‚ùå DM API Error:", data);
      return;
    }

    console.log("üì© DM Sent:", data);

  } catch (err) {
    console.error("‚ùå DM API Error:", err.message);
  }
}


